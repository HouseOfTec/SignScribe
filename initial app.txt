import { useEffect, useRef, useStae, useState } from "react";
import { HandLandmarker, FilesetResolver } from "@mediapipe/tasks-vision";

export default function App() {
  const videoRef = useRef(null);
  const canvasRef = useRef(null);
  const [landmarker, setLandermarker] = useState(null);
  const [ready, setReady] = useState(false);
  const [status, setStatus] = useState("click 'enable camera to start");
}

// ask fopr webcam once the user clicks the button 
const enableCamera = async () => {
  try {
    setStatus("Requesting camera");
const stream = await navigator.mediaDevices.getUserMedia({ video:true, audio: false});
if (videoRef.current){
  videoRef.current.srcObject = stream;
  await videoRef.current.play();
}
if (!landmarker) await initLandmarker();
setReady("true");
setStatus("Camera on. Detecting Hands...");
requestAnimationFrame(detectFrame);
} 
catch (err) {
console.error(err);
setStatus("camera permission was denied or not availabe");
 }
};

//Load the mediaPipe Tasks model (runs locally in yout browser)
const initLandmarker = async () => {
  const vision = await FilesetResolver.forVisionTasks(
    // loads the webassembly backend files from a CDN
    "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm"
  );
  const handLandmarker = await HandLandmarker.createFromOptions(vision, {
    baseOptions: {
      modelAsssetPath:
      "https://storage.googleapis.com/mediapipe-models/hand_landmarker/hand_landmarker/float16/latest/hand_landmarker.task",
    },
    numHands: 2,
    runningMode: "VIDEO"
  });
  setLandermarker(handLandmarker)
}

// draw circles for each landmark 
const drawLandmarks = (landmarksList, ctx, w, h) => {
  ctx.clearRect(0, 0, w, h);
  ctx.lineWidth = 2;
  for (const landmarks of landmarksList){
    for (const pt of landmarks) {
      const xm= pt.x * w;
      const y = pt.y * h;
      ctx.beginPath();
      ctx.arc(x,y,3,0, Math.PI * 2);
      ctx.fill();
    }
  }
};

//main detection loop 
const detectFrame= () =>{
  const video = videoRef.current;
  const canvas = canvasRef.current;
  if (!video || !canvas ||!landmark) {
    requestAnimationFrame(detectFrame);
    return;
} 
const w = video.videoWidth;
const h = video.videoHeight;
if (w === 0 || h ===0) {
  requestAnimationFrame(detectionFrame);
  return;
}

// Make canvas match the video feed size
if (canvas.width !==w) canvas.width = w;
if (canvas.height !== h) canvas.height= h;

const results = landmarker.detectForVideo(video, performance.now());

const ctx = canvas.getContext("2d");
if (results && results.landmarks && results.landmarks.length > 0) {
  drawLandmarks(results.landmarks, ctx, w, h);
} else{
  ctx.clearRect(0,0,w,h);
}
requestAnimationFrame(detectFrame);

};

//Clean up camera when unmounting
useEffect(() => {
  return () => {
    const stream = videoRef.current?.srcObject;
    if(stream) {
      stream.getTracks().forEach((t) => t.stop());
    }
  };
}, []);

return(
  <div style={{ 
    minHeight: "100svh",
    display: "grid", 
    placeItems: "center", 
    padding: 24,

  }}>
    <div style={{ width: "100%", maxWidth: 820 }}>
        <h1 style={{ marginBottom: 8 }}>SignScribe â€” Live Hand Tracking</h1>
        <p style={{ margin: "8px 0 16px", opacity: 0.8 }}>{status}</p>

        <div style={{ position: "relative", borderRadius: 16, overflow: "hidden", boxShadow: "0 8px 30px rgba(0,0,0,0.15)" }}>
          <video
            ref={videoRef}
            playsInline
            muted
            style={{ width: "100%", height: "auto", display: "block", transform: "scaleX(-1)" }} // mirror for selfie view
          />
          <canvas
            ref={canvasRef}
            style={{
              position: "absolute",
              inset: 0,
              width: "100%",
              height: "100%",
              pointerEvents: "none",
              transform: "scaleX(-1)", // match mirroring
            }}
          />
          </div>
          <div style={{ marginTop: 16, display: "flex", gap: 12 }}>
          <button
            onClick={enableCamera}
            disabled={ready}
            style={{
              padding: "10px 16px",
              borderRadius: 12,
              border: "1px solid #ccc",
              background: ready ? "#ffffffff" : "white",
              cursor: ready ? "not-allowed" : "pointer",
            }}
          >
            {ready ? "Camera Enabled" : "Enable camera"}
          </button>
        </div>
      </div>
    </div>
  );
